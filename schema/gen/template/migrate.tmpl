// Code generated by ent-elastic, DO NOT EDIT.

package migrate

import (
    "context"
    "fmt"
    "github.com/guihouchang/go-elasticsearch/schema/field"
    "github.com/olivere/elastic/v7"
    "reflect"
    "time"
)

var (
    {{range .}}
    {{ToCamelCase .Name}}Mapping = &field.Mapping{
        Name: "{{getTableName .}}",
        Properties: map[string]interface{}{
           {{range .Fields}}
            "{{ToUnderscore .Name}}": map[string]interface{}{
                "type": "{{ESType .Info.Type}}",
                {{range RendProperty .}}{{.}},
                {{end}}
            },
           {{end}}
        },
        {{ with .Annotations}}
            {{ with .Settings }}
        Settings: map[string]interface{} {
                {{ with .Settings}}{{ range $k, $v := .}}
                "{{$k}}": {{$v}},
                {{end}}{{end}}
            },
            {{else}}
        Settings: map[string]interface{}{},
            {{end}}
        {{else}}
        Settings: map[string]interface{}{},
        {{end}}

    }
    {{end}}

    Tables = []*field.Mapping{
        {{range .}}{{ToCamelCase .Name}}Mapping,{{end}}

    }
)

type Schema struct {
    client *elastic.Client
}

func NewSchema(client *elastic.Client) *Schema {
 return &Schema{client: client}
}

func (s *Schema) Create(ctx context.Context) error {
    return Create(ctx, s, Tables)
}

func checkUpdateMapping(subset, superset map[string]interface{}) bool {
    for key, value := range subset {
        // 检查键是否存在于超集中
        if supersetValue, ok := superset[key]; ok {
            // 检查对应值是否相等
            if !reflect.DeepEqual(supersetValue, value) {
                return true
            }
        } else {
            // 键不存在于超集中
            return true
        }
    }
    return false
}

func getProperties(mapping map[string]interface{}, name string) (map[string]interface{}, error) {
    if mappingData, ok := mapping[name]; ok {
        if tmpData, ok := mappingData.(map[string]interface{}); ok {
            if tmpData, ok := tmpData["mappings"]; ok {
                if tmpData, ok := tmpData.(map[string]interface{}); ok {
                    if tmpData, ok := tmpData["properties"]; ok {
                        if properties, ok := tmpData.(map[string]interface{}); ok {
                            return properties, nil
                        }
                    }
                }
            }
        }
    }

    return nil, fmt.Errorf("properties not found")
}

func Create(ctx context.Context, s *Schema, mappings []*field.Mapping) error {
    for _, m := range mappings {
        exist, err := s.client.IndexExists(m.Name).Do(ctx)
        if err != nil {
            return err
        }

        if !exist {
            _, err := s.client.CreateIndex(m.Name).BodyJson(m.CreateBody()).Do(ctx)
            if err != nil {
                return err
            }
        } else {
            // 获取当前的mapping
            mapping, err := s.client.GetMapping().Index(m.Name).Do(ctx)
            if err != nil {
                return err
            }

            properties, err := getProperties(mapping, m.Name)
            if err != nil {
                return err
            }

            // 比较mapping是否有变更，如果本地是远程的子集那么就不需要变更
            if !checkUpdateMapping(m.Properties, properties) {
                continue
            }

           // 先进行备份
           _, err = s.client.Reindex().Body(m.BackupBody()).Do(ctx)
           if err != nil {
               return err
           }

           // 删除旧索引
           _, err = s.client.DeleteIndex(m.Name).Do(ctx)
           if err != nil {
               return err
           }

           // 创建索引
           _, err = s.client.CreateIndex(m.Name).BodyJson(m.CreateBody()).Do(ctx)
           if err != nil {
               return err
           }

          exist, err := s.client.IndexExists(m.BackupName()).Do(ctx)
          if err != nil {
              return err
          }

          if exist {
              // 等待1秒生效后再恢复数据
              time.Sleep(time.Second)
              // 恢复数据
              _, err = s.client.Reindex().Body(m.RecoveryBody()).Do(ctx)
              if err != nil {
                return err
              }
              // 删除旧索引
              _, err = s.client.DeleteIndex(m.BackupName()).Do(ctx)
              if err != nil {
                  return err
              }
          }
        }
    }
    return nil
}