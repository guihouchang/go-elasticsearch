# go-elasticsearch

go-elasticsearch 用于生成elasticsearch ORM工具库。使用ent的方式去定义es的orm并生成对应的代码



## Getting Started
### Required
- [ent](https://github.com/ent/ent)
- [olivere/elastic](https://github.com/olivere/elastic)

### Installing
##### go install 安装：
```
go install github.com/guihouchang/go-elasticsearch/cmd/ent-elastic@latest
ent-elastic -v
```

### 定义Schema
```
# 创建es目录
mkdir es
cd es
# 在es目录下新建一个schema文件夹，并新建一个user.go文件
```
``` golang
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema"
	"github.com/guihouchang/go-elasticsearch/schema/annotation"
	esfield "github.com/guihouchang/go-elasticsearch/schema/field"
)

type UserData struct {
	ent.Schema
}

func (UserData) Fields() []ent.Field {
	return []ent.Field{
		esfield.Text("text_tttt").Analyzer("ik_max_word").SearchAnalyzer("ik_max_word"),
		esfield.Keyword("keyword_kkkk"),
		esfield.Byte("byte_bbbb"),
		esfield.Short("short_ssss"),
		esfield.Int("int_iiii"),
		esfield.Long("long_llll"),
		esfield.Float("float_ffff"),
		esfield.Double("double_ddddd"),
		esfield.Bool("bool_bbbb"),
		esfield.Date("date_dddd").Format("yyyy-MM-dd HH:mm:ss"),
	}
}

// Annotations of the schema.
func (UserData) Annotations() []schema.Annotation {
	return []schema.Annotation{
		annotation.Setting{Settings: map[string]interface{}{
			"number_of_shards":   1,
			"number_of_replicas": 2,
		}},
	}
}
```

# 生成代码
```shell
cd ./es && entc-elastic generate ./schema
```
# 生成的代码例子
migrate/schema.go
```golang

// Code generated by ent-elastic, DO NOT EDIT.

package migrate

import (
	"context"
	"github.com/guihouchang/go-elasticsearch/schema/field"
	"github.com/olivere/elastic/v7"
)

var (
	UserDataMapping = &field.Mapping{
		Name: "user_data",
		Properties: map[string]interface{}{

			"text_tttt": map[string]interface{}{
				"type":            "text",
				"analyzer":        "ik_max_word",
				"search_analyzer": "ik_max_word",
			},

			"keyword_kkkk": map[string]interface{}{
				"type": "keyword",
			},

			"byte_bbbb": map[string]interface{}{
				"type": "byte",
			},

			"short_ssss": map[string]interface{}{
				"type": "short",
			},

			"int_iiii": map[string]interface{}{
				"type": "integer",
			},

			"long_llll": map[string]interface{}{
				"type": "long",
			},

			"float_ffff": map[string]interface{}{
				"type": "float",
			},

			"double_ddddd": map[string]interface{}{
				"type": "double",
			},

			"bool_bbbb": map[string]interface{}{
				"type": "boolean",
			},

			"date_dddd": map[string]interface{}{
				"type":   "date",
				"format": "yyyy-MM-dd HH:mm:ss",
			},
		},

		Settings: map[string]interface{}{

			"number_of_replicas": 2,

			"number_of_shards": 1,
		},
	}

	Tables = []*field.Mapping{
		UserDataMapping,
	}
)

type Schema struct {
	client *elastic.Client
}

func NewSchema(client *elastic.Client) *Schema {
	return &Schema{client: client}
}

func (s *Schema) Create(ctx context.Context) error {
	return Create(ctx, s, Tables)
}

func Create(ctx context.Context, s *Schema, mappings []*field.Mapping) error {
	for _, m := range mappings {
		exist, err := s.client.IndexExists(m.Name).Do(ctx)
		if err != nil {
			return err
		}

		if !exist {
			_, err := s.client.CreateIndex(m.Name).BodyJson(m.CreateBody()).Do(ctx)
			if err != nil {
				return err
			}
		} else {
			// 先进行备份
			_, err := s.client.Reindex().Body(m.BackupBody()).Do(ctx)
			if err != nil {
				return err
			}

			// 删除旧索引
			_, err = s.client.DeleteIndex(m.Name).Do(ctx)
			if err != nil {
				return err
			}

			// 创建索引
			_, err = s.client.CreateIndex(m.Name).BodyJson(m.CreateBody()).Do(ctx)
			if err != nil {
				return err
			}

			exist, err := s.client.IndexExists(m.BackupName()).Do(ctx)
			if err != nil {
				return err
			}

			if exist {
				// 恢复数据
				_, err = s.client.Reindex().Body(m.RecoveryBody()).Do(ctx)
				// 删除旧索引
				_, err = s.client.DeleteIndex(m.BackupName()).Do(ctx)
				if err != nil {
					return err
				}
			}

			return err
		}
	}
	return nil
}

```
userdata/userdata.go
```golang
// Code generated by ent-elastic, DO NOT EDIT.
package userdata

const (
	Label = "user_data"

	FieldTextTttt = "text_tttt"

	FieldKeywordKkkk = "keyword_kkkk"

	FieldByteBbbb = "byte_bbbb"

	FieldShortSsss = "short_ssss"

	FieldIntIiii = "int_iiii"

	FieldLongLlll = "long_llll"

	FieldFloatFfff = "float_ffff"

	FieldDoubleDdddd = "double_ddddd"

	FieldBoolBbbb = "bool_bbbb"

	FieldDateDddd = "date_dddd"
)

```
client.go
```go
// Code generated by ent-elastic, DO NOT EDIT.
package es

import (
	"github.com/guihouchang/go-elasticsearch/test/migrate"
	"github.com/olivere/elastic/v7"
)

type Client struct {
	client *elastic.Client
	Schema *migrate.Schema
}

func NewClient(client *elastic.Client) *Client {
	return &Client{
		client: client,
		Schema: migrate.NewSchema(client),
	}
}

```
userdata.go
```go
// Code generated by ent-elastic, DO NOT EDIT.

package es

import (
	"encoding/json"
	"github.com/olivere/elastic/v7"
	"time"
)

type UserData struct {
	TextTttt string `json:"text_tttt,omitempty"`

	KeywordKkkk string `json:"keyword_kkkk,omitempty"`

	ByteBbbb int8 `json:"byte_bbbb,omitempty"`

	ShortSsss int16 `json:"short_ssss,omitempty"`

	IntIiii int32 `json:"int_iiii,omitempty"`

	LongLlll int64 `json:"long_llll,omitempty"`

	FloatFfff float32 `json:"float_ffff,omitempty"`

	DoubleDdddd float64 `json:"double_ddddd,omitempty"`

	BoolBbbb bool `json:"bool_bbbb,omitempty"`

	DateDddd time.Time `json:"date_dddd,omitempty"`
}

func UnserizerUserData(result *elastic.SearchResult) ([]*UserData, error) {
	datas := make([]*UserData, 0)
	for _, h := range result.Hits.Hits {
		data := &UserData{}
		err := json.Unmarshal(h.Source, data)
		if err != nil {
			return nil, err
		}

		datas = append(datas, data)
	}

	return datas, nil
}

```



